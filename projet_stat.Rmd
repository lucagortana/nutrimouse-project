---
title: "projet_stat"
output:
  word_document: default
date: "2023-01-18"
---

```{r, echo=FALSE}
setwd("~/Documents/3A/Stats/projet") #mettre votre directory
```

Dans les données « nutrimouse », nous avons les mesures de l'expression de 120 gènes potentiellement impliqués dans les problèmes nutritionnels des souris, les concentrations de 21 acides gras hépatiques et les génotypes de 40 souris soumises à 5 différents régimes.

"PPAR" est une abréviation pour "Peroxisome Proliferator-Activated Receptor", qui est un récepteur dans les cellules qui régule divers processus métaboliques, tels que la décomposition des graisses et la production d'énergie. 


## Librairies
```{r setup, include=FALSE}
library(corrplot)
library(FactoMineR)
library(factoextra)
library(glmnet)
library(MultiVarSel)
```

## Dataframe

```{r}
load('nutrimouse.rda')
```

## Pre-processing

```{r}
data_gene = nutrimouse[['gene']]
data_lipid = nutrimouse[['lipid']]
diet = nutrimouse[['diet']]
genotype = nutrimouse[['genotype']]
data_both = cbind(data_gene, data_lipid)
data_both_gen = cbind(diet, data_both)
data = cbind(genotype, data_both_gen)
rm(data_gene, data_lipid, diet, genotype, data_both, data_both_gen, nutrimouse)
```

```{r}
#summary(data)
str(data)
```

```{r}
X1 <- data[, 1]
X2 <- data[, 2]
table(X1, X2)
```

## Matrices de corrélation sur l'ensemble des individus

```{r}
data_gen <- data[, 1:122]
corrplot(cor(data_gen[, 3:122]))
```

```{r}
data_lipid <- cbind(data[,1:2], data[, 123:143])
corrplot(cor(data_lipid[, 3:23]))
```

## Matrices de corrélation sur chaque groupe de souris (wt ou ppar)

```{r}
data_lipid_wt <- cbind(data[1:20, 1:2], data[1:20, 123:143])
corrplot(cor(data_lipid_wt[,3:23]))
```

```{r}
data_lipid_ppar <- cbind(data[21:40,1:2], data[21:40, 123:143])
corrplot(cor(data_lipid_ppar[3:23]))
```

## PCA

```{r}
res.pca <- PCA(data_gen[,3:122], graph = FALSE) #TRUE affiche 2 graphes directement
get_eigenvalue(res.pca) #donne un tableau avec les valeurs propres
fviz_pca_var(res.pca, axes=1:2)
data_gen$genotype <- as.factor(data_gen$genotype)
colors <- c("red", "blue")
fviz_pca_ind(res.pca, axes = 1:2, geom = "point",
             habillage = data_gen$genotype,
             col.hab = colors,
             ggtheme = theme_classic(),
             legend = "bottom")
fviz_eig(res.pca, addlabels = TRUE, ylim = c(0,50)) #graphe avec inertie
```

```{r}
boxplot(data_gen[,3]~data_gen[,2], col = "green")
```

```{r}
boxplot(data_gen[,4]~data_gen[,2], col = "green")
```

```{r}
heatmap(abs(cor(data_gen[, -c(1,2)])), symm = TRUE)
```

```{r}
heatmap(abs(cor(data[, -c(1,2)])), symm = TRUE)
```

```{r}
ref_data <- subset(data, diet == "ref")
```

## Selection de variables 


Soit Y la matrice des acides gras
En ligne les individus en colonnes les differents acides gras.
Soit X la matrice des variables explicatives : les gènes. 

On suppose une indépendance des lignes sur les Ei.

```{r}
Y <- as.matrix(data_lipid[, -c(1, 2)])
X1 <- as.matrix(data[1])
X2 <- as.matrix(data[2])
dim(Y)
dim(X1)
dim(X2)
```

```{r}
X <- model.matrix(lm(Y~X1+0)) # on crée la matrice de design
p <- ncol(X) #2
n <- nrow(X) #40
q <- dim(Y)[2] #21
```

```{r}
Y <- scale(Y)
Y
```

```{r}
acp.res = PCA(Y, scale.unit = TRUE, nc = dim(Y)[2], graph = TRUE)
#fviz_pca_var(acp.res)
fviz_pca_ind(acp.res, geom.ind = "point", col.ind = X2)
```
Sélection des variables

```{r}
residuals <- lm(Y~X-1)$residuals
pvalue = whitening_test(residuals)
pvalue
```

P-value très faible, on rejette notre H0: nos colonnes sont dépendantes.
H0 = colonnes indépendantes,
H1 = colonnes dépendantes.

Nous ne pouvons pas vectoriser notre Y tel quel, il faut rendre indépendantes nos colonnes.

Nous allons blanchir nos données. Il faut choisir la méthode de blanchiement la plus adaptée.

```{r}
result=whitening_choice(residuals,c("AR1","nonparam","ARMA"),pAR=1,qMA=1)
result
```

Il faut connaître les différents principes associés à ces méthodes. Nous choisissons la méthode non-paramétrique.

```{r}
square_root_inv_hat_Sigma=whitening(residuals,"nonparam",pAR=1,qMA=0)
square_root_inv_hat_Sigma
```

--> Matrice par laquelle nous multiplions notre formule Y = XB + E afin de rendre indépendantes nos colonnes.

```{r}
# Blanchiement / vectorisation / LASSO / Stability selection 
Frequencies=variable_selection(Y,X,square_root_inv_hat_Sigma,nb_repli=500,parallel=FALSE)
head(Frequencies)
```

Dans la technique de "stability selection", nous allons sous-echantillonner plusieurs fois la moitié de nos observations. Ensuite, il calcule l'estimateur B à partir de ce sous-echantillon (en LASSO). À chaque itération on va regarder quelle variable explicative a été considérée comme informative. À la fin, on obtient le dataframe "Frequencies" avec la "fréquence de sélection" associé à chaque lipide et chaque génotype.

```{r}
Frequencies[Frequencies$frequency>=1,]
```

```{r}
colnames(Frequencies)<-c('Names_of_Y','Names_of_X','frequency')
Frequencies$Names_of_X<-sub('X1','',Frequencies$Names_of_X)
Frequencies$Names_of_X # "class0" "East" "West"
Frequencies$Names_of_Y<-as.numeric(gsub('X','',gsub('\\.1$','',Frequencies$Names_of_Y)))
Frequencies$Names_of_Y
```

```{r}
p<-ggplot(data=Frequencies[Frequencies$frequency>=0.95,],aes(x=Names_of_Y,y=Names_of_X,color=frequency))+geom_tile(size=0.75)+scale_color_gradient2(midpoint=0.95,mid ='orange')+theme_bw()+ylab('Levels of X')+xlab('m/z')
p
```

```{r}
p<-ggplot(data=Frequencies[Frequencies$frequency==1,],aes(x=Names_of_Y,y=Names_of_X,color=Names_of_X))+geom_point(size=1)+theme_bw()+ylab('Levels of X')+xlab('m/z') 
p
```

```{r}
new_lipid <- data_lipid[, -c(1, 2)][,Frequencies[Frequencies$frequency==1,]$Names_of_Y]
```

```{r}
resultats <- lm(as.matrix(new_lipid) ~ X)
summary(resultats)
```


